<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="192.168.8.136/feed.xml" rel="self" type="application/atom+xml" /><link href="192.168.8.136/" rel="alternate" type="text/html" /><updated>2021-03-01T20:23:39+01:00</updated><id>192.168.8.136/feed.xml</id><title type="html">Portfolio</title><subtitle>Projects created by Jonas Bodingbauer</subtitle><entry><title type="html">Breadboard Chip-8</title><link href="192.168.8.136/blog/Breadboard-Chip-8" rel="alternate" type="text/html" title="Breadboard Chip-8" /><published>2020-04-21T00:00:00+02:00</published><updated>2020-04-21T00:00:00+02:00</updated><id>192.168.8.136/blog/Breadboard%20Chip-8</id><content type="html" xml:base="192.168.8.136/blog/Breadboard-Chip-8">&lt;h1 id=&quot;description&quot;&gt;Description&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://de.wikipedia.org/wiki/CHIP-8&quot;&gt;Chip-8&lt;/a&gt; describes an “assembly-type” language as well as a typically interpreted virtual machine. I built a hardware CPU which is capable of every CHIP-8 instruction. This was a quite challenging task because I built everything as it arrived instead of having it perfectly planned in the beginning and some instructions are quite heavy-weight, where others are very simple.
The tutorials of &lt;a href=&quot;https://www.youtube.com/c/BenEater/videos&quot;&gt;Ben Eater&lt;/a&gt; inspired me to build this CPU. Instead of following this tutorial step by step I built many components myself and sometimes consulted his videos if I was unsure how to solve something. Because of the “build as I go” mentality I followed (partly because I did not understand everything in the beginning) the modules are not documented in detail which I really regret.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8Description.jpeg&quot; /&gt;
  &lt;figcaption&gt;Main modules marked in the Image&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;very-useful-resources-for-chip-8&quot;&gt;Very Useful Resources for Chip 8&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;My goto reference for the instruction set &lt;a href=&quot;http://devernay.free.fr/hacks/chip8/C8TECH10.HTM&quot;&gt;http://devernay.free.fr/hacks/chip8/C8TECH10.HTM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Awesome assembler, simulator,… &lt;a href=&quot;https://johnearnest.github.io/Octo/&quot;&gt;https://johnearnest.github.io/Octo/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Very clear tutorials for building a Breadboard CPU &lt;a href=&quot;https://www.youtube.com/c/BenEater/videos&quot;&gt;https://www.youtube.com/c/BenEater/videos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;caveats&quot;&gt;Caveats&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Because the whole build is based on Breadboards the contacts are degrading with time - 3 years after I built it, it is still working but sometimes glitches happen which is quite unfortunate.&lt;/li&gt;
  &lt;li&gt;Chip-8 has some Instructions which are not well-defined. I settled to use the standard settings of the &lt;a href=&quot;https://johnearnest.github.io/Octo/&quot;&gt;Octo&lt;/a&gt; project.&lt;/li&gt;
  &lt;li&gt;I mostly built it with components I had on hand or that were easily available - therefore some choices were made because of availability and not because of simplicity or elegance.&lt;/li&gt;
  &lt;li&gt;Because of limited space and money I sometimes combined parts of the CPU which should not be combined. For example, I used a single SRAM Chip to store REG A-F (which itself is quite ugly already) as well as the 16 address deep Stack.&lt;/li&gt;
  &lt;li&gt;Looking at it after a few years I made many questionable choices during bulding it - which I surely made because of poor planning. But all in all it was a really awesome learning experience and I still love to look at the mess of cables, breadboards and chips which somehow work in harmony (more or less).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;modules&quot;&gt;Modules&lt;/h1&gt;
&lt;h2 id=&quot;clock--state-control&quot;&gt;Clock &amp;amp; State Control&lt;/h2&gt;
&lt;p&gt;This is probably the easiest Module and very similar to the version of Ben Eater - it has an adjustable clock (astable 555) (~100Hz - 20kHz) as well as start and stop circuits. For the development process it also features a single stepping mode which uses a monostable 555 to generate pulses. A double-throw switch is used for program loading mode (which is explained in the RAM module).The last button on there is a reset-button which resets the PC and the microstep counter (inside the control logic).&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8/ClockAndRAM.JPG&quot; /&gt;
  &lt;figcaption&gt;A closer view of clock, RAM and Program-counter (from top to bottom)&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;program-counter&quot;&gt;Program Counter&lt;/h2&gt;
&lt;p&gt;The job of the program counter is to know where in the program we currently are. It mainly consists of 3 &lt;a href=&quot;https://assets.nexperia.com/documents/data-sheet/74HC_HCT193.pdf&quot;&gt;74HC193&lt;/a&gt; which are able to count up and down (only the up direction is used). The outputs are directly connected to the RAM (which is able to take addresses from PC or BUS depending on a control flag).&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;system-bus&quot;&gt;System-bus&lt;/h2&gt;
&lt;p&gt;Everything except PC Addresses to RAM are transmitted over the main bus in the middle. Each module is connected via 74HCT244 or 74HC245 tristate bus-drivers. This single bus is probably the biggest bottleneck but as it made interconnecting the components very simple (because the location did not need to be known at all) it fit my “build as I go” style very well. The biggest regret I have with this Bus is that I made it 12 bit wide. In the beginning of the project I thought that this is going to be useful because the addresses are 12-Bit wide. But in the end I used the full 12 bits for only 2 or 3 instructions - which definitely was not worth the trouble in the end.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ram&quot;&gt;RAM&lt;/h2&gt;
&lt;p&gt;The main building block of the RAM is a &lt;a href=&quot;https://pdf1.alldatasheet.com/datasheet-pdf/view/37298/SAMSUNG/KM62256CL.html&quot;&gt;KM62256&lt;/a&gt; 32Kx8bit SRAM. The RAM also features a KM28C64 EEPROM for loading the program into RAM. This program loading is achieved by switching a switch on the Clock&amp;amp;State Control and letting the CPU run for a few moments (less then 1/2 second) - contents from the EEPROM are copied to the RAM with every clock cycle.&lt;/p&gt;

&lt;p&gt;The rest of the circuit (which mostly consists of 74HC157 Multiplexers) is used to manually program the memory which was used during development.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;registers-a-f&quot;&gt;Registers A-F&lt;/h2&gt;
&lt;p&gt;This module also uses a single KM62256 (instead of single register chips for space reasons) to store the contents of registers A-F. The register to load or output is selected by the control logic using three control signals, the bus is used to transmit or receive the contents.&lt;/p&gt;

&lt;p&gt;The stack as well as the register I (12 bit Index-Register used for storing addresses) also resides inside the same SRAM (which is a pretty ugly design choice, but it worked). The Stack Pointer is also implemented directly in hardware with a &lt;a href=&quot;https://assets.nexperia.com/documents/data-sheet/74HC_HCT193.pdf&quot;&gt;74HC193&lt;/a&gt;. Using a Multiplexer 74HC157 the Stack Adresses as well as the Register addresses are correctly relayed to the SRAM module. This hardware - stackpointer allows for quicker execution of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RET&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALL&lt;/code&gt; instructions.&lt;/p&gt;
&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8/ALUandReg.JPG&quot; /&gt;
  &lt;figcaption&gt;A closer view of Register A-F, ALU and RNG(from top to bottom)&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;arithmetic-and-logic-unit&quot;&gt;Arithmetic and Logic Unit&lt;/h2&gt;
&lt;p&gt;The 12-bit-ALU (12 bits for the same reasons as mentioned in the System-BUS part) uses awesome &lt;a href=&quot;http://susta.cz/fel/74/pdf/sn_74181.pdf&quot;&gt;74LS181&lt;/a&gt; chips for doing subtraction, addition, comparison, logical operators, … . It is accompanied by four &lt;a href=&quot;https://assets.nexperia.com/documents/data-sheet/74HC_HCT377.pdf&quot;&gt;74HC377&lt;/a&gt; to load and store the operands from the BUS. As well as another 28C64 which is used to implement “esoteric” instructions such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LD B,Vx&lt;/code&gt; - “Store BCD representation of Vx in memory”. Simply using an EEPROM as a “calculator” was the easiest and space saving solution in this case.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;random-number-generator&quot;&gt;Random Number Generator&lt;/h2&gt;
&lt;p&gt;This CPU actually uses a hardware Random number generator. A simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt; would probably have been enough but I decided to try and make a white noise generator which is sampled at each clock. This analog circuit works well but is pretty sensible to the setting of the potentiometer which sets the decision level whether the voltage is interpreted as 0 or 1. In hindsight, I would definitely go for a LFSR instead of this circuit.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;control-logic&quot;&gt;Control Logic&lt;/h2&gt;
&lt;p&gt;This was probably the most complex part to develop because the Instructions of Chip-8 are quite hard to make sense of. The first 4 bits always indicate the type of operation - but the following 12 bits are quite universally used. Lets say an instruction looks like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Txyn&lt;/code&gt; where each letter stands for 4 bits in the instruction. Then n is sometimes used to indicate data but also sometimes details the type of instruction. For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8xy0&lt;/code&gt; stores the value of register y into register x - but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8xy1&lt;/code&gt; performs a bitwise or operation between the two registeres. Another example where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is used for data is the instruction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4xkk&lt;/code&gt; which skips the next instruction if the register x != kk. The instructions also use many addressing schemes like immediate, direct and index addressing which further complicates decoding.&lt;/p&gt;

&lt;p&gt;These issues were solved by using a few multiplexers and generic logic gates. The result of the “pre decoding” is then fed into four parallel flash memory chips &lt;a href=&quot;https://ww1.microchip.com/downloads/en/DeviceDoc/20005022C.pdf&quot;&gt;SST39SF02&lt;/a&gt; which store the microcode of the CPU. All in all there are 31 control signals which are driven by 21 (partly combined) output bits of these memory chips. Because the microcode also needs something similar like a Program-counter &lt;a href=&quot;https://www.ti.com/general/docs/suppproductinfo.tsp?distId=26&amp;amp;gotoUrl=http%3A%2F%2Fwww.ti.com%2Flit%2Fgpn%2Fsn74hc393&quot;&gt;74HC393&lt;/a&gt; was used to keep track of the position in the microcode. Because of some quite hard to implement instructions like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fx65&lt;/code&gt; - “Read registers V0 through Vx from memory starting at location I” (I is the Index-register) this counter was designed to count up to 64. The longest Instructions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fx65&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fx55&lt;/code&gt; use a whopping &lt;strong&gt;46&lt;/strong&gt; microsteps to complete. This is not typical at all - most instructions use somewhere around 6 microsteps (including 2 steps for fetching the instruction).&lt;/p&gt;
&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8/ControlBitsAndRNG.JPG&quot; /&gt;
  &lt;figcaption&gt;The state of all control-signals is indicated with Led's &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;microcode&quot;&gt;Microcode&lt;/h3&gt;
&lt;p&gt;The microcode is used to tell the modules what to do - step by step. A typical instruction (in this example adding two registers) looks like this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Load first Instruction Byte&lt;/li&gt;
  &lt;li&gt;Load second Instruction Byte - now the instruction is fully loaded and can be decoded&lt;/li&gt;
  &lt;li&gt;Load Register x into ALU Register A (via System-BUS)&lt;/li&gt;
  &lt;li&gt;Load Register y into ALU Register B (via System-BUS) - The ALU is told to add A and B by some control signals&lt;/li&gt;
  &lt;li&gt;Output the result to the BUS and store back into register x&lt;/li&gt;
  &lt;li&gt;Store Overflow Value in VF (this is an example which shows why having all Registers in SRAM was a questionable Idea)&lt;/li&gt;
  &lt;li&gt;Done (start from step 1 and load next instruction)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;creating-microcode&quot;&gt;Creating Microcode&lt;/h4&gt;
&lt;p&gt;To create the microcode I wrote a small Java application to transform a pretty basic notation of actions to memory maps for each of the four flash memories. It does not check if two actions are valid and simply sets the corresponding bits for each address.&lt;/p&gt;

&lt;p&gt;The actually used microcode for the Instruction described in &lt;a href=&quot;#microcode&quot;&gt;Microcode&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Vx + Vy , VF= Carry
x x 0: RAM	OEL	DEC	LDH	RB	LDL	PC	CNT //RAM outputs to BUS, Decoder High Register Loads, Program Counter is Incremented
x x 1: RAM	OEL	DEC	LDL	PC	CNT //RAM outputs to BUS, Decoder High Register Loads, Program Counter is Incremented
34 x 2: DEC	Rx  REG	OEL	RA	LDL //DEC Rx lets the Control Logic select Register x, REG OEL tells the Registers to Output its content to the BUS, RA LDL tells the ALU Register A to Load (the lower byte)
34 x 3: DEC	Ry  REG	OEL	RB	LDL	ALU	SUM //Same as above except Register y is selected
34 x 4: DEC	Rx  REG	LDL	ALU	OEL	ALU	SUM	FLA	LD //Register x loads from BUS, ALU outputs to BUS, FLAG bit is loaded
34 0 5: DEC	RF  REG	LDL	BCD	ONE	BCD	OE //If Flag was zero - RF is loading Value from Bus, BCD outouts one, BCD outputs one to BUS (BCD is the special EEPROM unit in the ALU)
34 1 5:	DEC	RF  REG	LDL	BCD	ZERO	BCD	OE //If Flag was one - RF is loading Value from Bus, BCD outouts one, BCD outputs zero to BUS
34 x 6: DEC	RES //Control Logic Resets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The numbers in the front indicate:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Predecoded value for the instruction&lt;/li&gt;
  &lt;li&gt;State of Flag (x-Don’t care,0 or 1)&lt;/li&gt;
  &lt;li&gt;Microinstruction Step count&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All values containing x mean that any value in this bit must decode to the given control signals. (e.g. x x 0 corresponds to 64(2^6 - Possible decoded Instructions)*2(Flag values)=128 addresses)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;graphics-card&quot;&gt;Graphics Card&lt;/h2&gt;
&lt;h3 id=&quot;cpu-side&quot;&gt;CPU side&lt;/h3&gt;
&lt;p&gt;There is only one instruction which allows writing to the display &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dxyn&lt;/code&gt; - “Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.” 
This instruction takes 26 steps because it needs to push up to 15 bytes to the gpu. The basic protocol in which CPU and GPU communicate looks like this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;(0-15) amount of Bytes to render to the display,&lt;/li&gt;
  &lt;li&gt;x-position&lt;/li&gt;
  &lt;li&gt;y-position&lt;/li&gt;
  &lt;li&gt;Up to 15 bytes containing the displayed data&lt;/li&gt;
  &lt;li&gt;If a bit cancelled a one to a zero in GPU-memory (because the bytes are written using XOR) this is noticed by the GPU and a signal goes high. That signas is received by CPU and a flag is set.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;cpu-microcode-for-drawing-to-the-display&quot;&gt;CPU Microcode for drawing to the display&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D x 2: PC	OEHL	RA	LD
D x 3: PC	LDL	REG	OEL	COM	REGIL	DEC	RF
D x 4: PC	LDH	REG	OEH	COM	REGIH	DEC	RF
D x 5: DEC	OE	DISP	LD
D x 6: REG	OEL	DISP	LD	DEC	Rx
D x 7: REG	OEL	DISP	LD	DEC	Ry
D x 8: RAM	OEL	DISP	LD	PC	CNT
D x 9: RAM	OEL	DISP	LD	PC	CNT
D x 10: RAM	OEL	DISP	LD	PC	CNT
D x 11: RAM	OEL	DISP	LD	PC	CNT
D x 12: RAM	OEL	DISP	LD	PC	CNT
D x 13: RAM	OEL	DISP	LD	PC	CNT
D x 14: RAM	OEL	DISP	LD	PC	CNT
D x 15: RAM	OEL	DISP	LD	PC	CNT
D x 16: RAM	OEL	DISP	LD	PC	CNT
D x 17: RAM	OEL	DISP	LD	PC	CNT
D x 18: RAM	OEL	DISP	LD	PC	CNT
D x 19: RAM	OEL	DISP	LD	PC	CNT
D x 20: RAM	OEL	DISP	LD	PC	CNT
D x 21: RAM	OEL	DISP	LD	PC	CNT	ALU	DISP
D x 22: RAM	OEL	DISP	LD	PC	CNT	ALU	DISP	FLA	LD
D x 23: ALU	DISP
D 0 24:	REG	LDL	DEC	RF	BCD	ZERO	BCD	OE
D 1 24: REG	LDL	DEC	RF	BCD	ONE	BCD	OE
D x 25: ALU	OEHL	ALU	A	PC	LD
D x 26: DEC	RES
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;gpu-side&quot;&gt;GPU side&lt;/h2&gt;
&lt;p&gt;Because the hardware required to drive the Led-matrix and interpret the CPU signals would be quite huge, I decided to use an FPGA instead of discrete components. Because I set out to build a CPU on a breadboard and not the entire system I think this is a good solution.&lt;/p&gt;

&lt;p&gt;The GPU is implemented in VHDL and runs inside an FPGA. Its job is to translate the protocol from above and set bits in memory accordingly.
The memory contents are continuously drawn to the Led-matrix display. This is quite a demanding task because the Led’s need to be PWM controlled as well as multiplexed. Heart of the operation inside the FPGA is a &lt;em&gt;dual-port RAM&lt;/em&gt; which allows reading and writing simultaneously at two ports. This is very useful because one port can be used by the CPU side - which is comparably very slow and the other port can be used by the logic to drive the matrix. Continously refreshing the matrix is accomplished with a finite state machine.&lt;/p&gt;

&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;I was able to run games such as tetris, pong and some awesome games from the &lt;a href=&quot;https://itch.io/jam/octojam-7&quot;&gt;Octojam&lt;/a&gt;. All in all I am very happy with the results and think the project was an awesome learning experience. If there were a second iteration I knew many things which I would approach differently, and I know what I would keep. If I had to set an approximate pricetag for all components I would say that it cost around 300€ - which is not too bad in my opinion.&lt;/p&gt;</content><author><name></name></author><category term="" /><summary type="html">Description Chip-8 describes an “assembly-type” language as well as a typically interpreted virtual machine. I built a hardware CPU which is capable of every CHIP-8 instruction. This was a quite challenging task because I built everything as it arrived instead of having it perfectly planned in the beginning and some instructions are quite heavy-weight, where others are very simple. The tutorials of Ben Eater inspired me to build this CPU. Instead of following this tutorial step by step I built many components myself and sometimes consulted his videos if I was unsure how to solve something. Because of the “build as I go” mentality I followed (partly because I did not understand everything in the beginning) the modules are not documented in detail which I really regret.</summary></entry><entry><title type="html">Flipdot Clock</title><link href="192.168.8.136/blog/FlipdotClock" rel="alternate" type="text/html" title="Flipdot Clock" /><published>2020-04-21T00:00:00+02:00</published><updated>2020-04-21T00:00:00+02:00</updated><id>192.168.8.136/blog/FlipdotClock</id><content type="html" xml:base="192.168.8.136/blog/FlipdotClock">&lt;h1 id=&quot;functionality&quot;&gt;Functionality&lt;/h1&gt;

&lt;p&gt;This project is a clock and display made out of an old LAWO &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-disc_display&quot;&gt;flipdot-display&lt;/a&gt;. It is able to display time, weather and departures of public transport near the place I live.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;flipdot-display&quot;&gt;Flipdot-display&lt;/h1&gt;

&lt;p&gt;A flipdot-display is using small magnetic disks which are black on one side and yellow on the other side. Small coils are driven in such a way, that these magnetic discs filp and stay (even if powered off). In this regard it behaves like an e-ink display. To magnetize the core of the coils to further flip the disk a small pulsed current is applied to the coils. The drive board consisting of basically an ATMEGA8 + ULN2803, UDN2983 and Linedecoders are developed at home. The software running on the ATMEGA8 receives data over the serial port and updates changed pixels for most efficient speed. Additionally, every n seconds each pixel is pulsed in order to prevent sticking of pixels.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/FlipdotClockDriver.jpg&quot; /&gt;
  &lt;figcaption&gt;Display Driver Board&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;I cannot fully remember why I decided to use that many negative output linedecoders and inverters when I just could have used 74HC237 - but I think the reseller did not have these in stock and I wanted to get everything done quickly. As the size of the pcb did not matter to me I probably just did not care.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/DriverCircuit.zip&quot;&gt;Eagle PCB and Schematics files&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;raspberry-pi&quot;&gt;Raspberry PI&lt;/h1&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/FlipdotClockBackside.jpg&quot; /&gt;
  &lt;figcaption&gt;Inside the whole assembly&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The Raspberry handles all internet connectivity and display logic. The time is automatically fetched via NTP. It also featured speech recognition based on &lt;a href=&quot;https://snips.ai/&quot;&gt;Snips AI&lt;/a&gt;. Unfortunately this project is now acquired by Sonos - and stopped support for makers. When I can make time for it, I will change the speech recognition to another open source project.&lt;/p&gt;

&lt;p&gt;Using commands like: “Snips - show Weather” the clock is able to be controlled by voice.&lt;/p&gt;

&lt;p&gt;Possible Screens which are implemented by now are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Time&lt;/li&gt;
  &lt;li&gt;Weather&lt;/li&gt;
  &lt;li&gt;Departures at local public transport stations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;games&quot;&gt;Games&lt;/h2&gt;
&lt;p&gt;It was also possible to play Games such as Pong and Snake on the clock. Unfortunately an old SD Card broke and the files from the controller where lost. It which was based on the &lt;a href=&quot;https://github.com/jehervy/node-virtual-gamepads&quot;&gt;Node-virtual gamepads Project&lt;/a&gt;. My version just modified the protocol a little bit to fit my needs better.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/A8e0DPhJKU4&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; style=&quot;display: block;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><category term="" /><summary type="html">Functionality</summary></entry><entry><title type="html">The Decision</title><link href="192.168.8.136/blog/TheDecision" rel="alternate" type="text/html" title="The Decision" /><published>2020-04-21T00:00:00+02:00</published><updated>2020-04-21T00:00:00+02:00</updated><id>192.168.8.136/blog/TheDecision</id><content type="html" xml:base="192.168.8.136/blog/TheDecision">&lt;h1 id=&quot;description&quot;&gt;Description&lt;/h1&gt;

&lt;p&gt;This game was &lt;em&gt;not&lt;/em&gt; meant to be a conventional computer game and is best seen as an experiment for two people. It has won the &lt;em&gt;Golden Nica&lt;/em&gt; in the Category “u19 - create your world” at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Prix_Ars_Electronica&quot;&gt;Prix Ars Electronica&lt;/a&gt; contest.&lt;/p&gt;

&lt;h1 id=&quot;plot&quot;&gt;Plot&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Die Entscheidung&lt;/em&gt; (The Decision) is a computer game for two players. What’s at stake is life or death, as one of the players reaches a verdict on the survival of the other, though this doesn’t become clear until the game is well underway.&lt;/p&gt;

&lt;p&gt;Player 1 acts out the life of a man who’s been diagnosed with cancer. The course of play offers numerous options as to what he can do during the remaining days of his life—for instance, the player can decide to spend time with his family, carry on with everyday life “as usual,” or fulfill his lifelong dreams.&lt;/p&gt;

&lt;p&gt;Player 2 simulates the cancer itself in that he can determine the decisive characteristics of the cancer cells. At the outset, he’s assigned the task of killing the Subject (as Player 1 is referred to). But over the course of the game, he receives information about events in the life of the man afflicted with cancer. Thus, he is repeatedly made aware of the fact that, through his actions, he influences the life of a human being. At the game’s climax, he has to decide whether to kill the Subject or not.&lt;/p&gt;

&lt;p&gt;The idea behind this game is based in part on the Milgram Experiment in which participants were called upon to carry out ethically dubious assignments. Although they were cognizant of the fact that they were causing a human being to suffer, they obeyed the instructions they received without considering the consequences.&lt;/p&gt;

&lt;p&gt;In many computer games, players have to perform tasks without giving any further thought to them. At the end of this game, both players are prompted to reflect upon the decisions they made.&lt;/p&gt;

&lt;h1 id=&quot;technicals&quot;&gt;Technicals&lt;/h1&gt;

&lt;p&gt;This game was developed in &lt;em&gt;Java&lt;/em&gt; using the engines &lt;a href=&quot;https://libgdx.com/&quot;&gt;LibGdx&lt;/a&gt; and &lt;a href=&quot;https://github.com/EsotericSoftware/kryonet&quot;&gt;KryoNet&lt;/a&gt; which are amazing to work with. The pixelart was created with &lt;a href=&quot;https://pyxeledit.com/&quot;&gt;PyxelEdit&lt;/a&gt; and &lt;a href=&quot;https://www.getpaint.net/&quot;&gt;Paint.Net&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;resources&quot;&gt;Resources&lt;/h1&gt;
&lt;p&gt;Since this project received some media attention I like to link to some Interviews and articles which covered this project - unfortunately almost all of them are in german.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://archive.aec.at/prix/showmode/55496/&quot;&gt;Ars Electronica Archive&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ars.electronica.art/aeblog/de/2016/08/26/die-entscheidung/&quot;&gt;Ars Electronica Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.derstandard.at/story/2000036720166/die-entscheidung-17-jaehriger-linzer-beeindruckt-mit-krebs-videospiel&quot;&gt;“Der Standard” News Article&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=rrY7_WwP7v8W&quot;&gt;Youtube Video of Jurors talking about my Game&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It was a great honor to be a part of the Festival and an amazing experience. I like to thank everyone involved!&lt;/p&gt;

&lt;div class=&quot;tile is-ancestor&quot;&gt;
  &lt;div class=&quot;tile is-vertical is-6&quot;&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungPark.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungKrankenhaus.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;tile is-vertical is-6&quot;&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungHome.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungChar.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><category term="" /><summary type="html">Description</summary></entry></feed>