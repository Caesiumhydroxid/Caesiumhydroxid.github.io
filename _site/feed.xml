<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="jonasb.at/feed.xml" rel="self" type="application/atom+xml" /><link href="jonasb.at/" rel="alternate" type="text/html" /><updated>2021-03-18T18:18:16+01:00</updated><id>jonasb.at/feed.xml</id><title type="html">Portfolio</title><subtitle>Projects created by Jonas Bodingbauer</subtitle><entry><title type="html">Magnet Pong</title><link href="jonasb.at/blog/Magnet-Pong" rel="alternate" type="text/html" title="Magnet Pong" /><published>2021-03-18T00:00:00+01:00</published><updated>2021-03-18T00:00:00+01:00</updated><id>jonasb.at/blog/Magnet%20Pong</id><content type="html" xml:base="jonasb.at/blog/Magnet-Pong">&lt;h1 id=&quot;description&quot;&gt;Description&lt;/h1&gt;

&lt;p&gt;This project is largely inspired by the &lt;a href=&quot;https://hackaday.io/project/164507-2d-stepper-motor-etched-on-pcb-micro-manipulator&quot;&gt;2D stepper motor&lt;/a&gt; from &lt;a href=&quot;https://hackaday.io/bobricius&quot;&gt;bobricius&lt;/a&gt; on hackaday. I loved the concept and thought I could make a Pong game from it. Little did I know that driving and designing this thing would result in lots of tinkering and head scratching but in the end I got my first (and only) PCB to work the way I wanted.&lt;/p&gt;

&lt;h1 id=&quot;design&quot;&gt;Design&lt;/h1&gt;

&lt;p&gt;With this project I not only wanted to try to build a Pong-Game, I also wanted to try out the SMT assembly service of &lt;a href=&quot;https://jlcpcb.com/&quot;&gt;jlcpcb&lt;/a&gt;. This influenced a lot of part choices - a good example for this is the &lt;a href=&quot;https://datasheet.lcsc.com/szlcsc/1810161611_Mixic-MX612E_C110207.pdf&quot;&gt;H-Bridge IC&lt;/a&gt;. Since I do not speak Chinese, I could not read the datasheet in its entirety and just hoped for the best.&lt;/p&gt;

&lt;h2 id=&quot;working-principle&quot;&gt;Working principle&lt;/h2&gt;
&lt;p&gt;The basic principle is the one of a stepper motor - just unfolded to a linear plane. There are 4 connections for each paddle and 8 connections (because of the x and y coordinate) for the ball. The PCB has two layers and the top and bottom layers are used for x and y coordinates respectively.&lt;/p&gt;

&lt;h2 id=&quot;schematic&quot;&gt;Schematic&lt;/h2&gt;

&lt;p&gt;The schematic is quite straightforward. Each linear stepper uses two H-Bridge drivers. The rest of the components just connects the H-Bridges, switches and power supply to the STM microcontroller. At first, I thought I might need a lot of power-resistors for driving the paddles. In the process of developing the software, I noticed that PWM was very effective and therefore I did not need to populate these and would definitely omit these in a redesign.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/PongSchematic.svg&quot; /&gt;
  &lt;figcaption&gt;Schmatic for the PCB &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;pcb&quot;&gt;PCB&lt;/h2&gt;

&lt;p&gt;I thought a lot about the thickness of the traces used for the steppers and I definitely wanted to make the wires on the bottom layer a little thicker to allow for more current. Because these are farther away from the magnets than the top layer and therefore need more current to achieve a similar force on the ball. The thickness was chosen to allow for approx. 1A and 1.5A current respectively at 5 V (which worked quite well). Unfortunately I messed up and made the top layer &lt;em&gt;thicker&lt;/em&gt; and the bottom layer &lt;em&gt;thinner&lt;/em&gt;. At first I thought that I needed to reorder the PCBs - but with some trial and error I could still get this version to work.&lt;/p&gt;

&lt;p&gt;In a redesign, because of the lessons I learned from this prototype, I would obviously correct my mistake and also make traces thicker in general. From testing, I learned that PWM was very effective (during design I was not sure if this would work because I could not read the specification of the H-Bridges and the forces would also be modulated) - but at around 30 kHz (to avoid audible PWM noises) everything works just fine.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/PongPCB.svg&quot; /&gt;
  &lt;figcaption&gt;Image of the PCB traces&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;software&quot;&gt;Software&lt;/h1&gt;

&lt;p&gt;The software of the STM32 is written using the &lt;a href=&quot;https://www.st.com/en/development-tools/stm32cubemx.html&quot;&gt;STM32CubeMX&lt;/a&gt; which was quite new for me as I mainly used ATmega controllers before. The abstraction from the hardware had a lot of pitfalls for me in the beginning, but I quickly learned to appreciate it. I used lots of timers for all the PWM as well as controlling the game.
When I could finally control the ball in a more or less reliable way (dust or other contamination sometimes make it lose a step) writing the game was quite straightforward. 
But until I managed to get the ball to behave I needed to go through quite a lot of things:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;controlling the x-Axis (top-side)&lt;/li&gt;
  &lt;li&gt;almost frying my H-bridges in the process&lt;/li&gt;
  &lt;li&gt;try adding the y-Axis&lt;/li&gt;
  &lt;li&gt;losing steps all the time on the y-Axis&lt;/li&gt;
  &lt;li&gt;almost frying my H-bridges again&lt;/li&gt;
  &lt;li&gt;adding PWM to x and y&lt;/li&gt;
  &lt;li&gt;noticing that drastically reducing current (though PWM) on the x-Axis helped a lot as friction decreased&lt;/li&gt;
  &lt;li&gt;tuning maximum step speed, PWM phase angles, PWM frequency,…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After a lot of debugging I finally ended up with a quite functional version for controlling the ball - controlling the paddles was “a walk in the park” comparatively, since they only had traces on the top layer.&lt;/p&gt;

&lt;h2 id=&quot;gamemodes&quot;&gt;Gamemodes&lt;/h2&gt;
&lt;p&gt;Obviously there is a &lt;strong&gt;two player&lt;/strong&gt; mode letting them compete. The first person to achieve 4 points wins. The points are displayed in binary format using LEDs on the bottom of the PCB.&lt;/p&gt;

&lt;p&gt;I also wrote a &lt;strong&gt;one player&lt;/strong&gt; mode. Until now, the opponent is programmed to play flawlessly. Therefore, it does not make a lot of fun to play in this mode at the moment (but was perfect for shooting the video at the top ;) ). If I have some free time (which is quite rare as I am writing this) I am probably going to change that.&lt;/p&gt;

&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;I am very happy about the outcome of this as everything works quite well by now. Playing with a physical object instead on a screen definitely changes the feel of the game - in my opinion in a very positive way.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/MagnetPong.jpg&quot; /&gt;
  &lt;figcaption&gt;Image of the real thing&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;I really learned a lot in the process of creating this game and hope that other people might like it as well :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/MagnetPong.zip&quot;&gt;KiCad-Files&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Write me a message if you want the source code. I also have some unused boards lying around at home - if you want one - you can also drop me a message.&lt;/p&gt;</content><author><name></name></author><category term="" /><summary type="html">Description</summary></entry><entry><title type="html">Numitron Clock</title><link href="jonasb.at/blog/Numitron-Clock" rel="alternate" type="text/html" title="Numitron Clock" /><published>2021-03-18T00:00:00+01:00</published><updated>2021-03-18T00:00:00+01:00</updated><id>jonasb.at/blog/Numitron%20Clock</id><content type="html" xml:base="jonasb.at/blog/Numitron-Clock">&lt;h1 id=&quot;description&quot;&gt;Description&lt;/h1&gt;

&lt;p&gt;This Clock is built with &lt;a href=&quot;http://www.tube-tester.com/sites/nixie/data/IV-9/iv-9.htm&quot;&gt;IV-9 Numitrons&lt;/a&gt;. They operate on voltages around 3-4V and take a driving current of approximately 20mA per Segment. There is no PCB used in this project and even the drivers in a SOP-Packages are soldered directly to copper wire.&lt;/p&gt;

&lt;p&gt;I was largely inspired by the projects of &lt;a href=&quot;https://www.bhoite.com/&quot;&gt;Mohit Bhoite&lt;/a&gt; whose work is really amazing.&lt;/p&gt;

&lt;h1 id=&quot;frame-and-wiring&quot;&gt;Frame and Wiring&lt;/h1&gt;
&lt;p&gt;All of the wiring is done using 1.5 mm² copper wire for the more stable parts as well as 0.75 mm² for some more intricate electrical connections. The wires are&lt;/p&gt;

&lt;h1 id=&quot;electronics&quot;&gt;Electronics&lt;/h1&gt;

&lt;p&gt;On the electronics side this clock is actually not really complicated - an ESP8266 is the brain of the operation. I chose it because it can connect to WIFI and in the future I can potentially use it to also display other numbers / data from the internet. The driving ICs are &lt;a href=&quot;https://www.st.com/resource/en/datasheet/stp16dp05.pdf&quot;&gt;STP16DP05MTR&lt;/a&gt; constant current LED drivers. This might seem like an awkward choice - but I think that the current limiting capabilities (I set it to about 18mA) are going to enhance the lifetime of my Numitrons - also other high current, open drain shift registers were quite equally priced. I also wasted 8 pins per register, but this made assembly (which was already quite tricky) a little easier.&lt;/p&gt;

&lt;p&gt;The ESP is connected to the daisy-chained shift registers and shifts out the current time. In the back of the Clock there is also a litte LDR digitized by the ADC - so the clock can shut off in the night.&lt;/p&gt;

&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;

&lt;p&gt;I really like how the clock looks and how it came out in the end. I struggled quite a lot with soldering SMD parts on wire and getting everything to align more or less well - but I think in the end it was worth the effort.&lt;/p&gt;

&lt;div class=&quot;tile is-ancestor&quot;&gt;
  &lt;div class=&quot;tile is-vertical is-12&quot;&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/NumitronSide.jpg&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/NumitronFront.jpg&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><category term="" /><summary type="html">Description</summary></entry><entry><title type="html">Breadboard Chip-8</title><link href="jonasb.at/blog/Breadboard-Chip-8" rel="alternate" type="text/html" title="Breadboard Chip-8" /><published>2020-04-21T00:00:00+02:00</published><updated>2020-04-21T00:00:00+02:00</updated><id>jonasb.at/blog/Breadboard%20Chip-8</id><content type="html" xml:base="jonasb.at/blog/Breadboard-Chip-8">&lt;h1 id=&quot;description&quot;&gt;Description&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://de.wikipedia.org/wiki/CHIP-8&quot;&gt;Chip-8&lt;/a&gt; describes an “assembly-type” language as well as a typically interpreted virtual machine. I built a hardware CPU which is capable of executing these CHIP-8 instruction. This was a quite challenging task because I built everything as it came instead of having it perfectly planned in the beginning and some instructions are quite heavy-weight, where others are very simple.
The tutorials of &lt;a href=&quot;https://www.youtube.com/c/BenEater/videos&quot;&gt;Ben Eater&lt;/a&gt; inspired me to build this CPU. Instead of following this tutorial step by step I built many components myself and sometimes consulted his videos if I was unsure how to solve something. Because of the “build as I go” mentality (partly because I did not understand everything in the beginning) the modules are not documented in detail which I really regret.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8Description.jpeg&quot; /&gt;
  &lt;figcaption&gt;Main modules of the CPU marked in the Image&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&quot;very-useful-resources-for-chip-8&quot;&gt;Very Useful Resources for Chip 8&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;My goto reference for the instruction set &lt;a href=&quot;http://devernay.free.fr/hacks/chip8/C8TECH10.HTM&quot;&gt;http://devernay.free.fr/hacks/chip8/C8TECH10.HTM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Awesome assembler, simulator,… &lt;a href=&quot;https://johnearnest.github.io/Octo/&quot;&gt;https://johnearnest.github.io/Octo/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Very clear tutorials for building a Breadboard CPU &lt;a href=&quot;https://www.youtube.com/c/BenEater/videos&quot;&gt;https://www.youtube.com/c/BenEater/videos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;caveats&quot;&gt;Caveats&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Because the whole build is based on breadboards the contacts are degrading with time — 3 years after I built it, it is still working, but sometimes glitches happen which is quite unfortunate.&lt;/li&gt;
  &lt;li&gt;Chip-8 has some Instructions which are not well-defined. I settled to use the standard settings of the &lt;a href=&quot;https://johnearnest.github.io/Octo/&quot;&gt;Octo&lt;/a&gt; project.&lt;/li&gt;
  &lt;li&gt;I mostly built it with components I had on hand or that were easily available — therefore some choices were made because of availability and not because of simplicity or elegance.&lt;/li&gt;
  &lt;li&gt;Because of limited space and money I sometimes combined parts of the CPU which should not be combined. For example, I used a single SRAM chip to store REG A-F (which itself is quite ugly already) as well as the 16 address deep stack.&lt;/li&gt;
  &lt;li&gt;Looking at it after a few years I made many questionable choices during building it - which I surely made because of poor planning. But all in all it was a really awesome learning experience and I still love to look at the mess of cables, breadboards and chips which somehow work in harmony (more or less).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;modules&quot;&gt;Modules&lt;/h1&gt;
&lt;h2 id=&quot;clock--state-control&quot;&gt;Clock &amp;amp; State Control&lt;/h2&gt;
&lt;p&gt;This is probably the easiest Module and very similar to the version of Ben Eater - it has an adjustable clock (astable 555) (~100Hz - 20kHz) as well as start and stop circuits. For the development process it also features a single stepping mode which uses a monostable 555 to generate pulses. A double-throw switch is used for program loading mode (which is explained in the RAM module). The last button on there is a reset-button which resets the PC and the microstep counter (inside the control logic).&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8/ClockAndRAM.jpg&quot; /&gt;
  &lt;figcaption&gt;A closer view of clock, RAM and Program-counter (from top to bottom)&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;program-counter&quot;&gt;Program Counter&lt;/h2&gt;
&lt;p&gt;The job of the program counter is to know where in the program we currently are. It mainly consists of 3 &lt;a href=&quot;https://assets.nexperia.com/documents/data-sheet/74HC_HCT193.pdf&quot;&gt;74HC193&lt;/a&gt; which are able to count up and down (only the up direction is used). The output address is directly connected to the RAM (which is able to take addresses from either PC or BUS depending on a control flag). The PC can also connect to the normal system bus to load and output its content.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;system-bus&quot;&gt;System-bus&lt;/h2&gt;
&lt;p&gt;Every word of data is transmitted over the main system bus located in the middle except the Program counter addresses (which is mentioned above). Each module is connected to the bus using 74HCT244 or 74HC245 tristate bus-drivers. This single bus is probably the biggest bottleneck but as it made interconnecting the components very simple (because the location of each module relative to other modules did not need to be known at all) it fit my “build as I go” style very well. The biggest regret I have with this bus is that I made it 12 bit wide. In the beginning of the project I thought that this is going to be useful because the address space of the CHIP-8 machine is 12-bit wide. But in the end I used the full 12 bits for only 2 or 3 instructions - which definitely was not worth the trouble in the end.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ram&quot;&gt;RAM&lt;/h2&gt;
&lt;p&gt;The main building block of the RAM is a &lt;a href=&quot;https://pdf1.alldatasheet.com/datasheet-pdf/view/37298/SAMSUNG/KM62256CL.html&quot;&gt;KM62256&lt;/a&gt; 32Kx8bit SRAM. The RAM also features a KM28C64 EEPROM for loading the program into RAM. This program loading is achieved by switching a switch on the Clock&amp;amp;State Control and letting the CPU run for a few moments (less then 1/2 second) - contents from the EEPROM are copied to the RAM with every clock cycle.&lt;/p&gt;

&lt;p&gt;The rest of the circuit (which mostly consists of 74HC157 Multiplexers) is used to manually program the memory which was used during development.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;registers-a-f-stack-stack-pointer-and-register-i&quot;&gt;Registers A-F, Stack, Stack-pointer and Register I&lt;/h2&gt;
&lt;p&gt;Registers are the place where the CPU stores values to operate with. Normally, the registers are a lot faster than the RAM - but in my case this module also uses a single KM62256 (instead of single register chips for space reasons) to store the contents of registers A-F. The registers are told to load from, or output to the bus, by the control logic using three control signals.&lt;/p&gt;

&lt;p&gt;The stack as well as the register I (12 bit Index-Register used for storing addresses) also reside inside the same SRAM-chip (which is a pretty ugly design choice, but it worked). The Stack-pointer is implemented directly in hardware using a settable counter &lt;a href=&quot;https://assets.nexperia.com/documents/data-sheet/74HC_HCT193.pdf&quot;&gt;74HC193&lt;/a&gt;. The Stack-pointer was implemented as a counter, because this allows for a little quicker execution of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RET&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALL&lt;/code&gt; instructions.
A Multiplexer 74HC157, controls whether the stack-addresses or the register addresses are relayed to the SRAM module.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8/ALUandReg.jpg&quot; /&gt;
  &lt;figcaption&gt;A closer view of Register A-F, ALU and RNG(from top to bottom)&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;arithmetic-and-logic-unit&quot;&gt;Arithmetic and Logic Unit&lt;/h2&gt;
&lt;p&gt;The 12-bit-ALU (12 bits for the same reasons as mentioned in the System-BUS part) uses the very useful &lt;a href=&quot;http://susta.cz/fel/74/pdf/sn_74181.pdf&quot;&gt;74LS181&lt;/a&gt; chips for doing arithmetic and logical operators. It is accompanied by four &lt;a href=&quot;https://assets.nexperia.com/documents/data-sheet/74HC_HCT377.pdf&quot;&gt;74HC377&lt;/a&gt; to load and store the operands from the bus. Another 28C64 EEPROM is used as a “single operand ALU” to implement “esoteric” instructions such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LD B,Vx&lt;/code&gt; - “Store BCD representation of Vx in memory”. Simply using an EEPROM as &lt;a href=&quot;http://39k.ca/using-roms-as-combinational-logic/&quot;&gt;combinatorial logic&lt;/a&gt; was the easiest and space-saving solution in this case I think.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;random-number-generator&quot;&gt;Random Number Generator&lt;/h2&gt;
&lt;p&gt;This CPU actually uses a hardware-Random number generator. A simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear-feedback_shift_register&quot;&gt;LFSR&lt;/a&gt; would probably have been sufficient, but I decided to try and make a white noise generator which is sampled using a shift register. This analog circuit works well but is pretty sensible to the setting of the potentiometer which sets a decision level (whether the voltage is interpreted as 0 or 1). In hindsight, I would definitely go for a LFSR instead of this circuit.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;control-logic&quot;&gt;Control Logic&lt;/h2&gt;
&lt;p&gt;This was probably the most complex part to develop because the instructions of Chip-8 are formatted in a quite impractical way. One instruction always consists out of two bytes. The first 4 bits always indicate the type of operation - but the following 12 bits are quite universally used. Let’s say an instruction looks like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Txyn&lt;/code&gt; where each letter stands for 4 bits in the instruction. Then n - part is sometimes used to indicate data, but also sometimes details the type of instruction. For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8xy0&lt;/code&gt; stores the value of register y into register x - but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8xy1&lt;/code&gt; performs a bitwise or operation between the two registers. Another example where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is used for data is the instruction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4xkk&lt;/code&gt; which skips the next instruction if the register Vx != kk. The instructions also use many addressing schemes like immediate, direct and index addressing which further complicates decoding.&lt;/p&gt;

&lt;p&gt;These issues were solved by using a few multiplexers and generic logic gates. The result of the “pre-decoding” done by this logic - a 6-bit code corresponding to each instruction, is then fed into four parallel flash memory chips &lt;a href=&quot;https://ww1.microchip.com/downloads/en/DeviceDoc/20005022C.pdf&quot;&gt;SST39SF02&lt;/a&gt; which store the &lt;a href=&quot;#microcode&quot;&gt;microcode&lt;/a&gt; of the CPU. The whole CPU uses 31 control signals which are driven by 21 (partly combined) output bits of these memory chips. To keep track of the state of execution for the microcode, we need something similar like a Program-counter. The counter &lt;a href=&quot;https://www.ti.com/general/docs/suppproductinfo.tsp?distId=26&amp;amp;gotoUrl=http%3A%2F%2Fwww.ti.com%2Flit%2Fgpn%2Fsn74hc393&quot;&gt;74HC393&lt;/a&gt; was used to keep track of the position in the microcode.&lt;/p&gt;

&lt;p&gt;Because of some, quite hard to implement instructions, this counter was designed to count up to 63. The longest Instructions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fx65&lt;/code&gt; - “Read registers V0 through Vx from memory starting at location I” (I is the Index-register) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fx55&lt;/code&gt; use a whopping &lt;strong&gt;46&lt;/strong&gt; microsteps to complete. This is not typical at all - most instructions use somewhere around 7 microsteps (including 2 steps for fetching the instruction). The next section will show how this microcode looks like in my cpu.&lt;/p&gt;
&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/Chip8/ControlBitsAndRNG.jpg&quot; /&gt;
  &lt;figcaption&gt;The state of all control-signals is indicated with LED's &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;microcode&quot;&gt;Microcode&lt;/h3&gt;
&lt;p&gt;The microcode is used by the control logic to tell the modules what to do - step by step. We are going to look at an example instruction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8xy4&lt;/code&gt; - “Add Registers x and y”. 
Typically, a CPU follows a &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction_cycle&quot;&gt;fetch-decode-execute-cycle&lt;/a&gt; - my CPU does so too. The steps needed to be taken by my CPU to execute the addition instruction, are the following:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Load first Instruction Byte&lt;/li&gt;
  &lt;li&gt;Load second Instruction Byte - now the instruction is fully loaded and can be decoded&lt;/li&gt;
  &lt;li&gt;Load Register x into ALU Register A (via system-bus)&lt;/li&gt;
  &lt;li&gt;Load Register y into ALU Register B (via system-bus) - The ALU is told to add A and B by some control signals&lt;/li&gt;
  &lt;li&gt;Output the result to the BUS and store back into register x&lt;/li&gt;
  &lt;li&gt;Store overflow-value in VF (this is an example which shows why having all registers in SRAM was a questionable Idea)&lt;/li&gt;
  &lt;li&gt;Done (start from step 1 and load next instruction)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;creating-microcode&quot;&gt;Creating Microcode&lt;/h4&gt;
&lt;p&gt;To create the microcode I wrote a small Java application to transform a pretty basic notation of actions to memory maps for each of the four flash memories. It does not check if two actions are valid and simply sets the corresponding bits for each address.&lt;/p&gt;

&lt;p&gt;The actual microcode I wrote for the Instruction described in &lt;a href=&quot;#microcode&quot;&gt;Microcode&lt;/a&gt; looks like this:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Vx + Vy , VF= Carry
x x 0: RAM	OEL	DEC	LDH	RB	LDL	PC	CNT //RAM outputs to BUS, Decoder High Register Loads, Program Counter is Incremented
x x 1: RAM	OEL	DEC	LDL	PC	CNT //RAM outputs to BUS, Decoder High Register Loads, Program Counter is Incremented
34 x 2: DEC	Rx  REG	OEL	RA	LDL //DEC Rx lets the Control Logic select Register x, REG OEL tells the Registers to Output its content to the BUS, RA LDL tells the ALU Register A to Load (the lower byte)
34 x 3: DEC	Ry  REG	OEL	RB	LDL	ALU	SUM //Same as above except Register y is selected
34 x 4: DEC	Rx  REG	LDL	ALU	OEL	ALU	SUM	FLA	LD //Register x loads from BUS, ALU outputs to BUS, FLAG bit is loaded
34 0 5: DEC	RF  REG	LDL	BCD	ONE	BCD	OE //If Flag was zero - RF is loading Value from Bus, BCD outputs one, BCD outputs one to BUS (BCD is the special EEPROM unit in the ALU)
34 1 5:	DEC	RF  REG	LDL	BCD	ZERO	BCD	OE //If Flag was one - RF is loading Value from Bus, BCD outputs one, BCD outputs zero to BUS
34 x 6: DEC	RES //Control Logic Resets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The numbers in the front indicate:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#control-logic&quot;&gt;Predecoded&lt;/a&gt; value for the instruction&lt;/li&gt;
  &lt;li&gt;State of Flag (x-Don’t care,0 or 1)&lt;/li&gt;
  &lt;li&gt;Micro-instruction step count&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All values containing x mean that any value in this bit must decode to the given control signals. That means one instruction must be written to more than one address in memory (which is once again used as &lt;a href=&quot;http://39k.ca/using-roms-as-combinational-logic/&quot;&gt;ROM combinatorial logic&lt;/a&gt;).
For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x x 0: ...&lt;/code&gt; corresponds to 64*2=128 addresses. The 64 comes from 2^6 possible decoded instructions, the 2 from the possible flag - states.&lt;/p&gt;

&lt;p&gt;Everything that follows these numbers are &lt;a href=&quot;https://en.wikipedia.org/wiki/Mnemonic&quot;&gt;Mnemonics&lt;/a&gt; which describe what the control signals should do. 
Every pair stands for a specific signal: e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RAM OEL&lt;/code&gt; means: module &lt;em&gt;RAM&lt;/em&gt; - &lt;strong&gt;o&lt;/strong&gt;utput to &lt;strong&gt;l&lt;/strong&gt;ower byte of bus. Many other examples can be seen in the code above.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;graphics-card&quot;&gt;Graphics Card&lt;/h2&gt;

&lt;p&gt;As mentioned above the GPU is implemented in an FPGA which handles the LED matrix as well as the communication with the CPU. Because the hardware required to drive the led matrix and interpret the CPU signals would be quite huge, I decided to use an FPGA instead of discrete components. Because I set out to build a CPU on a breadboard and not the entire system I think this is a good solution.&lt;/p&gt;

&lt;h3 id=&quot;cpu-side&quot;&gt;CPU side&lt;/h3&gt;
&lt;p&gt;There is only one instruction which allows writing to the display &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dxyn&lt;/code&gt; - “Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.” 
This instruction takes 26 steps because it needs to push up to 15 bytes to the GPU. The basic protocol in which CPU and GPU communicate looks like this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;(0-15) amount of Bytes to render to the display,&lt;/li&gt;
  &lt;li&gt;x-position&lt;/li&gt;
  &lt;li&gt;y-position&lt;/li&gt;
  &lt;li&gt;Up to 15 bytes containing the displayed data&lt;/li&gt;
  &lt;li&gt;If a bit cancelLED a one to a zero in GPU-memory (because the bytes are written using XOR) this is noticed by the GPU and a signal goes high. That signas is received by CPU and a flag is set.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;cpu-microcode-for-drawing-to-the-display&quot;&gt;CPU Microcode for drawing to the display&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D x 2: PC	OEHL	RA	LD
D x 3: PC	LDL	REG	OEL	COM	REGIL	DEC	RF
D x 4: PC	LDH	REG	OEH	COM	REGIH	DEC	RF
D x 5: DEC	OE	DISP	LD
D x 6: REG	OEL	DISP	LD	DEC	Rx
D x 7: REG	OEL	DISP	LD	DEC	Ry
D x 8: RAM	OEL	DISP	LD	PC	CNT
D x 9: RAM	OEL	DISP	LD	PC	CNT
D x 10: RAM	OEL	DISP	LD	PC	CNT
D x 11: RAM	OEL	DISP	LD	PC	CNT
D x 12: RAM	OEL	DISP	LD	PC	CNT
D x 13: RAM	OEL	DISP	LD	PC	CNT
D x 14: RAM	OEL	DISP	LD	PC	CNT
D x 15: RAM	OEL	DISP	LD	PC	CNT
D x 16: RAM	OEL	DISP	LD	PC	CNT
D x 17: RAM	OEL	DISP	LD	PC	CNT
D x 18: RAM	OEL	DISP	LD	PC	CNT
D x 19: RAM	OEL	DISP	LD	PC	CNT
D x 20: RAM	OEL	DISP	LD	PC	CNT
D x 21: RAM	OEL	DISP	LD	PC	CNT	ALU	DISP
D x 22: RAM	OEL	DISP	LD	PC	CNT	ALU	DISP	FLA	LD
D x 23: ALU	DISP
D 0 24:	REG	LDL	DEC	RF	BCD	ZERO	BCD	OE
D 1 24: REG	LDL	DEC	RF	BCD	ONE	BCD	OE
D x 25: ALU	OEHL	ALU	A	PC	LD
D x 26: DEC	RES
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;gpu-side&quot;&gt;GPU side&lt;/h2&gt;

&lt;p&gt;The GPU is implemented in VHDL and runs inside an FPGA. Its job is to translate the protocol from above and set bits in memory accordingly.
The memory contents are continuously drawn to the LED-matrix display. This is quite a demanding task because the LED’s need to be PWM controlled as well as multiplexed. Heart of the operation inside the FPGA is a &lt;em&gt;dual-port RAM&lt;/em&gt; which allows reading and writing simultaneously at two ports. This is very useful because the CPU side and the LED-matrix side can be separated completely. One port can be used by the CPU side — which is comparably very slow. The other port can be used by the logic to drive the matrix.
Controlling the process of multiplexing and PWM is handled by a &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;Finite-state machine&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;I was able to run games such as Tetris, Pong and some awesome games from the &lt;a href=&quot;https://itch.io/jam/octojam-7&quot;&gt;Octojam&lt;/a&gt;. All in all I am very happy with the results and think the project was an awesome learning experience. If there were a second iteration I knew many things which I would approach differently, and I know what I would keep. If I had to set an approximate price tag for all components I would say that it cost around 300€ - which is not too bad in my opinion.&lt;/p&gt;</content><author><name></name></author><category term="" /><summary type="html">Description Chip-8 describes an “assembly-type” language as well as a typically interpreted virtual machine. I built a hardware CPU which is capable of executing these CHIP-8 instruction. This was a quite challenging task because I built everything as it came instead of having it perfectly planned in the beginning and some instructions are quite heavy-weight, where others are very simple. The tutorials of Ben Eater inspired me to build this CPU. Instead of following this tutorial step by step I built many components myself and sometimes consulted his videos if I was unsure how to solve something. Because of the “build as I go” mentality (partly because I did not understand everything in the beginning) the modules are not documented in detail which I really regret.</summary></entry><entry><title type="html">Flipdot Clock</title><link href="jonasb.at/blog/FlipdotClock" rel="alternate" type="text/html" title="Flipdot Clock" /><published>2020-04-21T00:00:00+02:00</published><updated>2020-04-21T00:00:00+02:00</updated><id>jonasb.at/blog/FlipdotClock</id><content type="html" xml:base="jonasb.at/blog/FlipdotClock">&lt;h1 id=&quot;functionality&quot;&gt;Functionality&lt;/h1&gt;

&lt;p&gt;This project is a clock and display made out of an old LAWO &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-disc_display&quot;&gt;flipdot-display&lt;/a&gt;. It is able to display time, weather and departures of public transport near the place I live.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;flipdot-display&quot;&gt;Flipdot-display&lt;/h1&gt;

&lt;p&gt;A flipdot-display is using small magnetic disks which are black on one side and yellow on the other side. Small coils are driven in such a way, that these magnetic discs filp and stay (even if powered off). In this regard it behaves like an e-ink display. To magnetize the core of the coils to further flip the disk a small pulsed current is applied to the coils. The drive board consisting of basically an ATMEGA8 + ULN2803, UDN2983 and Linedecoders are developed at home. The software running on the ATMEGA8 receives data over the serial port and updates changed pixels for most efficient speed. Additionally, every n seconds each pixel is pulsed in order to prevent sticking of pixels.&lt;/p&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/FlipdotClockDriver.jpg&quot; /&gt;
  &lt;figcaption&gt;Display Driver Board&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;I cannot fully remember why I decided to use that many negative output linedecoders and inverters when I just could have used 74HC237 - but I think the reseller did not have these in stock and I wanted to get everything done quickly. As the size of the pcb did not matter to me I probably just did not care.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/DriverCircuit.zip&quot;&gt;Eagle PCB and Schematics files&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;raspberry-pi&quot;&gt;Raspberry PI&lt;/h1&gt;

&lt;figure&gt;
  &lt;img class=&quot;post-image&quot; src=&quot;/assets/images/FlipdotClockBackside.jpg&quot; /&gt;
  &lt;figcaption&gt;Inside the whole assembly&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The Raspberry handles all internet connectivity and display logic. The time is automatically fetched via NTP. It also featured speech recognition based on &lt;a href=&quot;https://snips.ai/&quot;&gt;Snips AI&lt;/a&gt;. Unfortunately this project is now acquired by Sonos - and stopped support for makers. When I can make time for it, I will change the speech recognition to another open source project.&lt;/p&gt;

&lt;p&gt;Using commands like: “Snips - show Weather” the clock is able to be controlled by voice.&lt;/p&gt;

&lt;p&gt;Possible Screens which are implemented by now are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Time&lt;/li&gt;
  &lt;li&gt;Weather&lt;/li&gt;
  &lt;li&gt;Departures at local public transport stations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;games&quot;&gt;Games&lt;/h2&gt;
&lt;p&gt;It was also possible to play Games such as Pong and Snake on the clock. Unfortunately an old SD Card broke and the files from the controller where lost. It which was based on the &lt;a href=&quot;https://github.com/jehervy/node-virtual-gamepads&quot;&gt;Node-virtual gamepads Project&lt;/a&gt;. My version just modified the protocol a little bit to fit my needs better.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/A8e0DPhJKU4&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; style=&quot;display: block;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><category term="" /><summary type="html">Functionality</summary></entry><entry><title type="html">The Decision</title><link href="jonasb.at/blog/TheDecision" rel="alternate" type="text/html" title="The Decision" /><published>2020-04-21T00:00:00+02:00</published><updated>2020-04-21T00:00:00+02:00</updated><id>jonasb.at/blog/TheDecision</id><content type="html" xml:base="jonasb.at/blog/TheDecision">&lt;h1 id=&quot;description&quot;&gt;Description&lt;/h1&gt;

&lt;p&gt;This game was &lt;em&gt;not&lt;/em&gt; meant to be a conventional computer game and is best seen as an experiment for two people. It has won the &lt;em&gt;Golden Nica&lt;/em&gt; in the Category “u19 - create your world” at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Prix_Ars_Electronica&quot;&gt;Prix Ars Electronica&lt;/a&gt; contest.&lt;/p&gt;

&lt;h1 id=&quot;plot&quot;&gt;Plot&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Die Entscheidung&lt;/em&gt; (The Decision) is a computer game for two players. What’s at stake is life or death, as one of the players reaches a verdict on the survival of the other, though this doesn’t become clear until the game is well underway.&lt;/p&gt;

&lt;p&gt;Player 1 acts out the life of a man who’s been diagnosed with cancer. The course of play offers numerous options as to what he can do during the remaining days of his life—for instance, the player can decide to spend time with his family, carry on with everyday life “as usual,” or fulfill his lifelong dreams.&lt;/p&gt;

&lt;p&gt;Player 2 simulates the cancer itself in that he can determine the decisive characteristics of the cancer cells. At the outset, he’s assigned the task of killing the Subject (as Player 1 is referred to). But over the course of the game, he receives information about events in the life of the man afflicted with cancer. Thus, he is repeatedly made aware of the fact that, through his actions, he influences the life of a human being. At the game’s climax, he has to decide whether to kill the Subject or not.&lt;/p&gt;

&lt;p&gt;The idea behind this game is based in part on the Milgram Experiment in which participants were called upon to carry out ethically dubious assignments. Although they were cognizant of the fact that they were causing a human being to suffer, they obeyed the instructions they received without considering the consequences.&lt;/p&gt;

&lt;p&gt;In many computer games, players have to perform tasks without giving any further thought to them. At the end of this game, both players are prompted to reflect upon the decisions they made.&lt;/p&gt;

&lt;h1 id=&quot;technicals&quot;&gt;Technicals&lt;/h1&gt;

&lt;p&gt;This game was developed in &lt;em&gt;Java&lt;/em&gt; using the engines &lt;a href=&quot;https://libgdx.com/&quot;&gt;LibGdx&lt;/a&gt; and &lt;a href=&quot;https://github.com/EsotericSoftware/kryonet&quot;&gt;KryoNet&lt;/a&gt; which are amazing to work with. The pixelart was created with &lt;a href=&quot;https://pyxeledit.com/&quot;&gt;PyxelEdit&lt;/a&gt; and &lt;a href=&quot;https://www.getpaint.net/&quot;&gt;Paint.Net&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;resources&quot;&gt;Resources&lt;/h1&gt;
&lt;p&gt;Since this project received some media attention I like to link to some Interviews and articles which covered this project - unfortunately almost all of them are in german.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://archive.aec.at/prix/showmode/55496/&quot;&gt;Ars Electronica Archive&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ars.electronica.art/aeblog/de/2016/08/26/die-entscheidung/&quot;&gt;Ars Electronica Blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.derstandard.at/story/2000036720166/die-entscheidung-17-jaehriger-linzer-beeindruckt-mit-krebs-videospiel&quot;&gt;“Der Standard” News Article&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=rrY7_WwP7v8W&quot;&gt;Youtube Video of Jurors talking about my Game&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It was a great honor to be a part of the Festival and an amazing experience. I like to thank everyone involved!&lt;/p&gt;

&lt;div class=&quot;tile is-ancestor&quot;&gt;
  &lt;div class=&quot;tile is-vertical is-6&quot;&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungPark.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungKrankenhaus.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;tile is-vertical is-6&quot;&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image is-16by9&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungHome.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
    &lt;div class=&quot;tile is-parent&quot;&gt;
      &lt;article class=&quot;tile is-child&quot;&gt;
        &lt;figure class=&quot;image&quot;&gt;
          &lt;img src=&quot;/assets/images/DieEntscheidungChar.png&quot; style=&quot;image-rendering: pixelated;image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;&quot; /&gt;
        &lt;/figure&gt;
      &lt;/article&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><category term="" /><summary type="html">Description</summary></entry></feed>